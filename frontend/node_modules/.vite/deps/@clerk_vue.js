import {
  Fragment,
  Teleport,
  Text,
  computed,
  createBlock,
  createElementBlock,
  createVNode,
  defineComponent,
  h,
  inject,
  mergeProps,
  onUnmounted,
  openBlock,
  provide,
  ref,
  renderSlot,
  resolveDynamicComponent,
  shallowRef,
  triggerRef,
  useAttrs,
  useSlots,
  watch,
  watchEffect,
  withCtx
} from "./chunk-FPSX4A45.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@clerk/shared/dist/runtime/error-Dl9xmUf3.mjs
function createErrorTypeGuard(ErrorClass) {
  function typeGuard(error) {
    const target = error ?? this;
    if (!target) throw new TypeError(`${ErrorClass.kind || ErrorClass.name} type guard requires an error object`);
    if (ErrorClass.kind && typeof target === "object" && target !== null && "constructor" in target) {
      if (target.constructor?.kind === ErrorClass.kind) return true;
    }
    return target instanceof ErrorClass;
  }
  return typeGuard;
}
var ClerkAPIError = class {
  static kind = "ClerkApiError";
  code;
  message;
  longMessage;
  meta;
  constructor(json) {
    const parsedError = {
      code: json.code,
      message: json.message,
      longMessage: json.long_message,
      meta: {
        paramName: json.meta?.param_name,
        sessionId: json.meta?.session_id,
        emailAddresses: json.meta?.email_addresses,
        identifiers: json.meta?.identifiers,
        zxcvbn: json.meta?.zxcvbn,
        plan: json.meta?.plan,
        isPlanUpgradePossible: json.meta?.is_plan_upgrade_possible
      }
    };
    this.code = parsedError.code;
    this.message = parsedError.message;
    this.longMessage = parsedError.longMessage;
    this.meta = parsedError.meta;
  }
};
var isClerkAPIError = createErrorTypeGuard(ClerkAPIError);
var ClerkError = class ClerkError2 extends Error {
  static kind = "ClerkError";
  clerkError = true;
  code;
  longMessage;
  docsUrl;
  cause;
  get name() {
    return this.constructor.name;
  }
  constructor(opts) {
    super(new.target.formatMessage(new.target.kind, opts.message, opts.code, opts.docsUrl), { cause: opts.cause });
    Object.setPrototypeOf(this, ClerkError2.prototype);
    this.code = opts.code;
    this.docsUrl = opts.docsUrl;
    this.longMessage = opts.longMessage;
    this.cause = opts.cause;
  }
  toString() {
    return `[${this.name}]
Message:${this.message}`;
  }
  static formatMessage(name, msg, code, docsUrl) {
    const prefix = "Clerk:";
    const regex = new RegExp(prefix.replace(" ", "\\s*"), "i");
    msg = msg.replace(regex, "");
    msg = `${prefix} ${msg.trim()}

(code="${code}")

`;
    if (docsUrl) msg += `

Docs: ${docsUrl}`;
    return msg;
  }
};
var ClerkAPIResponseError = class ClerkAPIResponseError2 extends ClerkError {
  static kind = "ClerkAPIResponseError";
  status;
  clerkTraceId;
  retryAfter;
  errors;
  constructor(message, options) {
    const { data: errorsJson, status, clerkTraceId, retryAfter } = options;
    super({
      ...options,
      message,
      code: "api_response_error"
    });
    Object.setPrototypeOf(this, ClerkAPIResponseError2.prototype);
    this.status = status;
    this.clerkTraceId = clerkTraceId;
    this.retryAfter = retryAfter;
    this.errors = (errorsJson || []).map((e) => new ClerkAPIError(e));
  }
  toString() {
    let message = `[${this.name}]
Message:${this.message}
Status:${this.status}
Serialized errors: ${this.errors.map((e) => JSON.stringify(e))}`;
    if (this.clerkTraceId) message += `
Clerk Trace ID: ${this.clerkTraceId}`;
    return message;
  }
  static formatMessage(name, msg, _, __) {
    return msg;
  }
};
var isClerkAPIResponseError = createErrorTypeGuard(ClerkAPIResponseError);
var DefaultMessages = Object.freeze({
  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
});
function buildErrorThrower({ packageName, customMessages }) {
  let pkg = packageName;
  function buildMessage(rawMessage, replacements) {
    if (!replacements) return `${pkg}: ${rawMessage}`;
    let msg = rawMessage;
    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const match of matches) {
      const replacement = (replacements[match[1]] || "").toString();
      msg = msg.replace(`{{${match[1]}}}`, replacement);
    }
    return `${pkg}: ${msg}`;
  }
  const messages = {
    ...DefaultMessages,
    ...customMessages
  };
  return {
    setPackageName({ packageName: packageName$1 }) {
      if (typeof packageName$1 === "string") pkg = packageName$1;
      return this;
    },
    setMessages({ customMessages: customMessages$1 }) {
      Object.assign(messages, customMessages$1 || {});
      return this;
    },
    throwInvalidPublishableKeyError(params) {
      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
    },
    throwInvalidProxyUrl(params) {
      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
    },
    throwMissingPublishableKeyError() {
      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(params) {
      throw new Error(buildMessage(messages.MissingClerkProvider, params));
    },
    throw(message) {
      throw new Error(buildMessage(message));
    }
  };
}
var ClerkRuntimeError = class ClerkRuntimeError2 extends ClerkError {
  static kind = "ClerkRuntimeError";
  /**
  * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.
  */
  clerkRuntimeError = true;
  constructor(message, options) {
    super({
      ...options,
      message
    });
    Object.setPrototypeOf(this, ClerkRuntimeError2.prototype);
  }
};
var isClerkRuntimeError = createErrorTypeGuard(ClerkRuntimeError);

// node_modules/@clerk/vue/dist/chunk-Q3ZTPL6B.js
var errorThrower = buildErrorThrower({ packageName: "@clerk/vue" });
function setErrorThrowerOptions(options) {
  errorThrower.setMessages(options).setPackageName(options);
}

// node_modules/@clerk/shared/dist/runtime/authorization-D2ans7vW.mjs
var TYPES_TO_OBJECTS = {
  strict_mfa: {
    afterMinutes: 10,
    level: "multi_factor"
  },
  strict: {
    afterMinutes: 10,
    level: "second_factor"
  },
  moderate: {
    afterMinutes: 60,
    level: "second_factor"
  },
  lax: {
    afterMinutes: 1440,
    level: "second_factor"
  }
};
var ALLOWED_LEVELS = /* @__PURE__ */ new Set([
  "first_factor",
  "second_factor",
  "multi_factor"
]);
var ALLOWED_TYPES = /* @__PURE__ */ new Set([
  "strict_mfa",
  "strict",
  "moderate",
  "lax"
]);
var isValidMaxAge = (maxAge) => typeof maxAge === "number" && maxAge > 0;
var isValidLevel = (level) => ALLOWED_LEVELS.has(level);
var isValidVerificationType = (type) => ALLOWED_TYPES.has(type);
var prefixWithOrg = (value) => value.replace(/^(org:)*/, "org:");
var checkOrgAuthorization = (params, options) => {
  const { orgId, orgRole, orgPermissions } = options;
  if (!params.role && !params.permission) return null;
  if (!orgId || !orgRole || !orgPermissions) return null;
  if (params.permission) return orgPermissions.includes(prefixWithOrg(params.permission));
  if (params.role) return prefixWithOrg(orgRole) === prefixWithOrg(params.role);
  return null;
};
var checkForFeatureOrPlan = (claim, featureOrPlan) => {
  const { org: orgFeatures, user: userFeatures } = splitByScope(claim);
  const [scope, _id] = featureOrPlan.split(":");
  const id = _id || scope;
  if (scope === "org") return orgFeatures.includes(id);
  else if (scope === "user") return userFeatures.includes(id);
  else return [...orgFeatures, ...userFeatures].includes(id);
};
var checkBillingAuthorization = (params, options) => {
  const { features, plans } = options;
  if (params.feature && features) return checkForFeatureOrPlan(features, params.feature);
  if (params.plan && plans) return checkForFeatureOrPlan(plans, params.plan);
  return null;
};
var splitByScope = (fea) => {
  const features = fea ? fea.split(",").map((f) => f.trim()) : [];
  return {
    org: features.filter((f) => f.split(":")[0].includes("o")).map((f) => f.split(":")[1]),
    user: features.filter((f) => f.split(":")[0].includes("u")).map((f) => f.split(":")[1])
  };
};
var validateReverificationConfig = (config) => {
  if (!config) return false;
  const convertConfigToObject = (config$1) => {
    if (typeof config$1 === "string") return TYPES_TO_OBJECTS[config$1];
    return config$1;
  };
  const isValidStringValue = typeof config === "string" && isValidVerificationType(config);
  const isValidObjectValue = typeof config === "object" && isValidLevel(config.level) && isValidMaxAge(config.afterMinutes);
  if (isValidStringValue || isValidObjectValue) return convertConfigToObject.bind(null, config);
  return false;
};
var checkReverificationAuthorization = (params, { factorVerificationAge }) => {
  if (!params.reverification || !factorVerificationAge) return null;
  const isValidReverification = validateReverificationConfig(params.reverification);
  if (!isValidReverification) return null;
  const { level, afterMinutes } = isValidReverification();
  const [factor1Age, factor2Age] = factorVerificationAge;
  const isValidFactor1 = factor1Age !== -1 ? afterMinutes > factor1Age : null;
  const isValidFactor2 = factor2Age !== -1 ? afterMinutes > factor2Age : null;
  switch (level) {
    case "first_factor":
      return isValidFactor1;
    case "second_factor":
      return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;
    case "multi_factor":
      return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;
  }
};
var createCheckAuthorization = (options) => {
  return (params) => {
    if (!options.userId) return false;
    const billingAuthorization = checkBillingAuthorization(params, options);
    const orgAuthorization = checkOrgAuthorization(params, options);
    const reverificationAuthorization = checkReverificationAuthorization(params, options);
    if ([billingAuthorization || orgAuthorization, reverificationAuthorization].some((a) => a === null)) return [billingAuthorization || orgAuthorization, reverificationAuthorization].some((a) => a === true);
    return [billingAuthorization || orgAuthorization, reverificationAuthorization].every((a) => a === true);
  };
};
var resolveAuthState = ({ authObject: { sessionId, sessionStatus, userId, actor, orgId, orgRole, orgSlug, signOut, getToken, has, sessionClaims }, options: { treatPendingAsSignedOut = true } }) => {
  if (sessionId === void 0 && userId === void 0) return {
    isLoaded: false,
    isSignedIn: void 0,
    sessionId,
    sessionClaims: void 0,
    userId,
    actor: void 0,
    orgId: void 0,
    orgRole: void 0,
    orgSlug: void 0,
    has: void 0,
    signOut,
    getToken
  };
  if (sessionId === null && userId === null) return {
    isLoaded: true,
    isSignedIn: false,
    sessionId,
    userId,
    sessionClaims: null,
    actor: null,
    orgId: null,
    orgRole: null,
    orgSlug: null,
    has: () => false,
    signOut,
    getToken
  };
  if (treatPendingAsSignedOut && sessionStatus === "pending") return {
    isLoaded: true,
    isSignedIn: false,
    sessionId: null,
    userId: null,
    sessionClaims: null,
    actor: null,
    orgId: null,
    orgRole: null,
    orgSlug: null,
    has: () => false,
    signOut,
    getToken
  };
  if (!!sessionId && !!sessionClaims && !!userId && !!orgId && !!orgRole) return {
    isLoaded: true,
    isSignedIn: true,
    sessionId,
    sessionClaims,
    userId,
    actor: actor || null,
    orgId,
    orgRole,
    orgSlug: orgSlug || null,
    has,
    signOut,
    getToken
  };
  if (!!sessionId && !!sessionClaims && !!userId && !orgId) return {
    isLoaded: true,
    isSignedIn: true,
    sessionId,
    sessionClaims,
    userId,
    actor: actor || null,
    orgId: null,
    orgRole: null,
    orgSlug: null,
    has,
    signOut,
    getToken
  };
};

// node_modules/@clerk/vue/dist/chunk-43M7PP4R.js
var ClerkInjectionKey = /* @__PURE__ */ Symbol("clerk");
var UserButtonInjectionKey = /* @__PURE__ */ Symbol("UserButton");
var UserButtonMenuItemsInjectionKey = /* @__PURE__ */ Symbol("UserButton.MenuItems");
var UserProfileInjectionKey = /* @__PURE__ */ Symbol("UserProfile");
var OrganizationProfileInjectionKey = /* @__PURE__ */ Symbol("OrganizationProfile");
function useClerkContext(source) {
  const ctx = inject(ClerkInjectionKey);
  if (!ctx) {
    return errorThrower.throw(
      `${source} can only be used when the Vue plugin is installed. Learn more: https://clerk.com/docs/reference/vue/clerk-plugin`
    );
  }
  return ctx;
}
var useClerk = () => {
  const { clerk } = useClerkContext("useClerk");
  return clerk;
};
var multipleChildrenInButtonComponent = (name) => `You've passed multiple children components to <${name}/>. You can only pass a single child component or text.`;
var invalidStateError = "Invalid state. Feel free to submit a bug or reach out to support here: https://clerk.com/support";
var userButtonMenuActionRenderedError = "<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.";
var userButtonMenuLinkRenderedError = "<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.";
var userButtonMenuItemLinkWrongProps = "Missing requirements. <UserButton.Link /> component requires props: href, label and slots: labelIcon.";
var userButtonMenuItemActionWrongProps = "Missing requirements. <UserButton.Action /> component requires props: label and slots: labelIcon.";
var userButtonMenuItemsRenderedError = "<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.";
var customPageWrongProps = (componentName) => `Missing requirements. <${componentName}.Page /> component requires props: url, label and slots: labelIcon and a default slot for page content`;
var customLinkWrongProps = (componentName) => `Missing requirements. <${componentName}.Link /> component requires the following props: url, label and slots: labelIcon.`;
var userProfilePageRenderedError = "<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.";
var userProfileLinkRenderedError = "<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.";
var organizationProfilePageRenderedError = "<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.";
var organizationProfileLinkRenderedError = "<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.";
var normalizeWithDefaultValue = (slotContent, defaultValue) => {
  if (!slotContent) {
    return h("button", defaultValue);
  }
  if (slotContent[0].type === Text) {
    return h("button", slotContent);
  }
  return slotContent;
};
var assertSingleChild = (slotContent, name) => {
  if (Array.isArray(slotContent)) {
    if (slotContent.length > 1) {
      return errorThrower.throw(multipleChildrenInButtonComponent(name));
    }
    return slotContent[0];
  }
  return slotContent;
};
function toComputedRefs(objectRef) {
  const result = {};
  for (const key in objectRef.value) {
    result[key] = computed(() => objectRef.value[key]);
  }
  return result;
}
function clerkLoaded(clerk) {
  return new Promise((resolve) => {
    let unwatch;
    unwatch = watch(
      clerk,
      (value) => {
        if (value?.loaded) {
          resolve(value);
          unwatch?.();
        }
      },
      { immediate: true }
    );
  });
}
function createGetToken(clerk) {
  return async (options) => {
    const loadedClerk = await clerkLoaded(clerk);
    if (!loadedClerk.session) {
      return null;
    }
    return loadedClerk.session.getToken(options);
  };
}
function createSignOut(clerk) {
  return async (...args) => {
    const loadedClerk = await clerkLoaded(clerk);
    return loadedClerk.signOut(...args);
  };
}
var useAuth = (options = {}) => {
  const { clerk, authCtx } = useClerkContext("useAuth");
  const getToken = createGetToken(clerk);
  const signOut = createSignOut(clerk);
  const result = computed(() => {
    const { userId, orgId, orgRole, orgPermissions, sessionClaims, factorVerificationAge } = authCtx.value;
    const has = createCheckAuthorization({
      userId,
      orgId,
      orgRole,
      orgPermissions,
      factorVerificationAge,
      features: sessionClaims?.fea || "",
      plans: sessionClaims?.pla || ""
    });
    const payload = resolveAuthState({
      authObject: {
        ...authCtx.value,
        getToken,
        signOut,
        has
      },
      options: {
        treatPendingAsSignedOut: options.treatPendingAsSignedOut
      }
    });
    if (!payload) {
      return errorThrower.throw(invalidStateError);
    }
    return payload;
  });
  return toComputedRefs(result);
};
var export_helper_default = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

// node_modules/@clerk/shared/dist/runtime/constants-ByUssRbE.mjs
var DEV_OR_STAGING_SUFFIXES = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
];

// node_modules/@clerk/shared/dist/runtime/isomorphicAtob-DybBXGFR.mjs
var isomorphicAtob = (data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") return atob(data);
  else if (typeof global !== "undefined" && global.Buffer) return new global.Buffer(data, "base64").toString();
  return data;
};

// node_modules/@clerk/shared/dist/runtime/keys-YNv6yjKk.mjs
var PUBLISHABLE_KEY_LIVE_PREFIX = "pk_live_";
var PUBLISHABLE_KEY_TEST_PREFIX = "pk_test_";
function isValidDecodedPublishableKey(decoded) {
  if (!decoded.endsWith("$")) return false;
  const withoutTrailing = decoded.slice(0, -1);
  if (withoutTrailing.includes("$")) return false;
  return withoutTrailing.includes(".");
}
function parsePublishableKey(key, options = {}) {
  key = key || "";
  if (!key || !isPublishableKey(key)) {
    if (options.fatal && !key) throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
    if (options.fatal && !isPublishableKey(key)) throw new Error("Publishable key not valid.");
    return null;
  }
  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? "production" : "development";
  let decodedFrontendApi;
  try {
    decodedFrontendApi = isomorphicAtob(key.split("_")[2]);
  } catch {
    if (options.fatal) throw new Error("Publishable key not valid: Failed to decode key.");
    return null;
  }
  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {
    if (options.fatal) throw new Error("Publishable key not valid: Decoded key has invalid format.");
    return null;
  }
  let frontendApi = decodedFrontendApi.slice(0, -1);
  if (options.proxyUrl) frontendApi = options.proxyUrl;
  else if (instanceType !== "development" && options.domain && options.isSatellite) frontendApi = `clerk.${options.domain}`;
  return {
    instanceType,
    frontendApi
  };
}
function isPublishableKey(key = "") {
  try {
    if (!(key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX))) return false;
    const parts = key.split("_");
    if (parts.length !== 3) return false;
    const encodedPart = parts[2];
    if (!encodedPart) return false;
    return isValidDecodedPublishableKey(isomorphicAtob(encodedPart));
  } catch {
    return false;
  }
}
function createDevOrStagingUrlCache() {
  const devOrStagingUrlCache = /* @__PURE__ */ new Map();
  return { isDevOrStagingUrl: (url) => {
    if (!url) return false;
    const hostname = typeof url === "string" ? url : url.hostname;
    let res = devOrStagingUrlCache.get(hostname);
    if (res === void 0) {
      res = DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));
      devOrStagingUrlCache.set(hostname, res);
    }
    return res;
  } };
}

// node_modules/@clerk/shared/dist/runtime/retry-DAlTROH9.mjs
var defaultOptions = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (_, iteration) => iteration < 5,
  retryImmediately: false,
  jitter: true
};
var RETRY_IMMEDIATELY_DELAY = 100;
var sleep = async (ms) => new Promise((s) => setTimeout(s, ms));
var applyJitter = (delay, jitter) => {
  return jitter ? delay * (1 + Math.random()) : delay;
};
var createExponentialDelayAsyncFn = (opts) => {
  let timesCalled = 0;
  const calculateDelayInMs = () => {
    const constant = opts.initialDelay;
    const base = opts.factor;
    let delay = constant * Math.pow(base, timesCalled);
    delay = applyJitter(delay, opts.jitter);
    return Math.min(opts.maxDelayBetweenRetries || delay, delay);
  };
  return async () => {
    await sleep(calculateDelayInMs());
    timesCalled++;
  };
};
var retry = async (callback, options = {}) => {
  let iterations = 0;
  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter, onBeforeRetry } = {
    ...defaultOptions,
    ...options
  };
  const delay = createExponentialDelayAsyncFn({
    initialDelay,
    maxDelayBetweenRetries,
    factor,
    jitter
  });
  while (true) try {
    return await callback();
  } catch (e) {
    iterations++;
    if (!shouldRetry(e, iterations)) throw e;
    if (onBeforeRetry) await onBeforeRetry(iterations);
    if (retryImmediately && iterations === 1) await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));
    else await delay();
  }
};

// node_modules/@clerk/shared/dist/runtime/loadScript-t1vaIfy5.mjs
var NO_DOCUMENT_ERROR = "loadScript cannot be called when document does not exist";
var NO_SRC_ERROR = "loadScript cannot be called without a src";
async function loadScript(src = "", opts) {
  const { async, defer, beforeLoad, crossOrigin, nonce } = opts || {};
  const load = () => {
    return new Promise((resolve, reject) => {
      if (!src) reject(new Error(NO_SRC_ERROR));
      if (!document || !document.body) reject(new Error(NO_DOCUMENT_ERROR));
      const script = document.createElement("script");
      if (crossOrigin) script.setAttribute("crossorigin", crossOrigin);
      script.async = async || false;
      script.defer = defer || false;
      script.addEventListener("load", () => {
        script.remove();
        resolve(script);
      });
      script.addEventListener("error", (event) => {
        script.remove();
        reject(event.error ?? new Error(`failed to load script: ${src}`));
      });
      script.src = src;
      script.nonce = nonce;
      beforeLoad?.(script);
      document.body.appendChild(script);
    });
  };
  return retry(load, { shouldRetry: (_, iterations) => iterations <= 5 });
}

// node_modules/@clerk/shared/dist/runtime/proxy-Bq8EHApG.mjs
function isValidProxyUrl(key) {
  if (!key) return true;
  return isHttpOrHttps(key) || isProxyUrlRelative(key);
}
function isHttpOrHttps(key) {
  return /^http(s)?:\/\//.test(key || "");
}
function isProxyUrlRelative(key) {
  return key.startsWith("/");
}
function proxyUrlToAbsoluteURL(url) {
  if (!url) return "";
  return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;
}

// node_modules/@clerk/shared/dist/runtime/url-Cdy8w8vK.mjs
function addClerkPrefix(str) {
  if (!str) return "";
  let regex;
  if (str.match(/^(clerk\.)+\w*$/)) regex = /(clerk\.)*(?=clerk\.)/;
  else if (str.match(/\.clerk.accounts/)) return str;
  else regex = /^(clerk\.)*/gi;
  return `clerk.${str.replace(regex, "")}`;
}

// node_modules/@clerk/shared/dist/runtime/versionSelector-Dusdw80C.mjs
var versionSelector = (clerkJSVersion, packageVersion = "5.122.0") => {
  if (clerkJSVersion) return clerkJSVersion;
  const prereleaseTag = getPrereleaseTag(packageVersion);
  if (prereleaseTag) {
    if (prereleaseTag === "snapshot") return "5.122.0";
    return prereleaseTag;
  }
  return getMajorVersion(packageVersion);
};
var getPrereleaseTag = (packageVersion) => packageVersion.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)?.[1];
var getMajorVersion = (packageVersion) => packageVersion.trim().replace(/^v/, "").split(".")[0];

// node_modules/@clerk/shared/dist/runtime/loadClerkJsScript-Dz_r2Obb.mjs
var ERROR_CODE = "failed_to_load_clerk_js";
var ERROR_CODE_TIMEOUT = "failed_to_load_clerk_js_timeout";
var FAILED_TO_LOAD_ERROR = "Failed to load Clerk";
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();
var errorThrower2 = buildErrorThrower({ packageName: "@clerk/shared" });
function setClerkJsLoadingErrorPackageName(packageName) {
  errorThrower2.setPackageName({ packageName });
}
function isClerkProperlyLoaded() {
  if (typeof window === "undefined" || !window.Clerk) return false;
  const clerk = window.Clerk;
  return typeof clerk === "object" && typeof clerk.load === "function";
}
function hasScriptRequestError(scriptUrl) {
  if (typeof window === "undefined" || !window.performance) return false;
  const entries = performance.getEntriesByName(scriptUrl, "resource");
  if (entries.length === 0) return false;
  const scriptEntry = entries[entries.length - 1];
  if (scriptEntry.transferSize === 0 && scriptEntry.decodedBodySize === 0) {
    if (scriptEntry.responseEnd === 0) return true;
    if (scriptEntry.responseEnd > 0 && scriptEntry.responseStart > 0) return true;
    if ("responseStatus" in scriptEntry) {
      if (scriptEntry.responseStatus >= 400) return true;
      if (scriptEntry.responseStatus === 0) return true;
    }
  }
  return false;
}
function waitForClerkWithTimeout(timeoutMs, existingScript) {
  return new Promise((resolve, reject) => {
    let resolved = false;
    const cleanup = (timeoutId$1, pollInterval$1) => {
      clearTimeout(timeoutId$1);
      clearInterval(pollInterval$1);
    };
    existingScript?.addEventListener("error", () => {
      cleanup(timeoutId, pollInterval);
      reject(new ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE }));
    });
    const checkAndResolve = () => {
      if (resolved) return;
      if (isClerkProperlyLoaded()) {
        resolved = true;
        cleanup(timeoutId, pollInterval);
        resolve(null);
      }
    };
    const handleTimeout = () => {
      if (resolved) return;
      resolved = true;
      cleanup(timeoutId, pollInterval);
      if (!isClerkProperlyLoaded()) reject(new ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE_TIMEOUT }));
      else resolve(null);
    };
    const timeoutId = setTimeout(handleTimeout, timeoutMs);
    checkAndResolve();
    const pollInterval = setInterval(() => {
      if (resolved) {
        clearInterval(pollInterval);
        return;
      }
      checkAndResolve();
    }, 100);
  });
}
var loadClerkJsScript = async (opts) => {
  const timeout = opts?.scriptLoadTimeout ?? 15e3;
  if (isClerkProperlyLoaded()) return null;
  if (!opts?.publishableKey) {
    errorThrower2.throwMissingPublishableKeyError();
    return null;
  }
  const scriptUrl = clerkJsScriptUrl(opts);
  const existingScript = document.querySelector("script[data-clerk-js-script]");
  if (existingScript) if (hasScriptRequestError(scriptUrl)) existingScript.remove();
  else try {
    await waitForClerkWithTimeout(timeout, existingScript);
    return null;
  } catch {
    existingScript.remove();
  }
  const loadPromise = waitForClerkWithTimeout(timeout);
  loadScript(scriptUrl, {
    async: true,
    crossOrigin: "anonymous",
    nonce: opts.nonce,
    beforeLoad: applyClerkJsScriptAttributes(opts)
  }).catch((error) => {
    throw new ClerkRuntimeError(FAILED_TO_LOAD_ERROR + (error.message ? `, ${error.message}` : ""), {
      code: ERROR_CODE,
      cause: error
    });
  });
  return loadPromise;
};
var clerkJsScriptUrl = (opts) => {
  const { clerkJSUrl, clerkJSVariant, clerkJSVersion, proxyUrl, domain, publishableKey } = opts;
  if (clerkJSUrl) return clerkJSUrl;
  let scriptHost = "";
  if (!!proxyUrl && isValidProxyUrl(proxyUrl)) scriptHost = proxyUrlToAbsoluteURL(proxyUrl).replace(/http(s)?:\/\//, "");
  else if (domain && !isDevOrStagingUrl(parsePublishableKey(publishableKey)?.frontendApi || "")) scriptHost = addClerkPrefix(domain);
  else scriptHost = parsePublishableKey(publishableKey)?.frontendApi || "";
  const variant = clerkJSVariant ? `${clerkJSVariant.replace(/\.+$/, "")}.` : "";
  const version = versionSelector(clerkJSVersion);
  return `https://${scriptHost}/npm/@clerk/clerk-js@${version}/dist/clerk.${variant}browser.js`;
};
var buildClerkJsScriptAttributes = (options) => {
  const obj = {};
  if (options.publishableKey) obj["data-clerk-publishable-key"] = options.publishableKey;
  if (options.proxyUrl) obj["data-clerk-proxy-url"] = options.proxyUrl;
  if (options.domain) obj["data-clerk-domain"] = options.domain;
  if (options.nonce) obj.nonce = options.nonce;
  return obj;
};
var applyClerkJsScriptAttributes = (options) => (script) => {
  const attributes = buildClerkJsScriptAttributes(options);
  for (const attribute in attributes) script.setAttribute(attribute, attributes[attribute]);
};

// node_modules/@clerk/shared/dist/runtime/runtimeEnvironment-BB2sO-19.mjs
var isDevelopmentEnvironment = () => {
  try {
    return true;
  } catch {
  }
  return false;
};
var isTestEnvironment = () => {
  try {
    return false;
  } catch {
  }
  return false;
};
var isProductionEnvironment = () => {
  try {
    return false;
  } catch {
  }
  return false;
};

// node_modules/@clerk/shared/dist/runtime/deprecated-BqlFbLHj.mjs
var displayedWarnings = /* @__PURE__ */ new Set();
var deprecated = (fnName, warning, key) => {
  const hideWarning = isTestEnvironment() || isProductionEnvironment();
  const messageId = key ?? fnName;
  if (displayedWarnings.has(messageId) || hideWarning) return;
  displayedWarnings.add(messageId);
  console.warn(`Clerk - DEPRECATION WARNING: "${fnName}" is deprecated and will be removed in the next major release.
${warning}`);
};

// node_modules/@clerk/shared/dist/runtime/underscore-DjQrhefX.mjs
function snakeToCamel(str) {
  return str ? str.replace(/([-_][a-z])/g, (match) => match.toUpperCase().replace(/-|_/, "")) : "";
}
function camelToSnake(str) {
  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : "";
}
var createDeepObjectTransformer = (transform) => {
  const deepTransform = (obj) => {
    if (!obj) return obj;
    if (Array.isArray(obj)) return obj.map((el) => {
      if (typeof el === "object" || Array.isArray(el)) return deepTransform(el);
      return el;
    });
    const copy = { ...obj };
    const keys = Object.keys(copy);
    for (const oldName of keys) {
      const newName = transform(oldName.toString());
      if (newName !== oldName) {
        copy[newName] = copy[oldName];
        delete copy[oldName];
      }
      if (typeof copy[newName] === "object") copy[newName] = deepTransform(copy[newName]);
    }
    return copy;
  };
  return deepTransform;
};
var deepCamelToSnake = createDeepObjectTransformer(camelToSnake);
var deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);

// node_modules/@clerk/shared/dist/runtime/telemetry-wqMDWlvR.mjs
var EVENT_METHOD_CALLED = "METHOD_CALLED";
var EVENT_SAMPLING_RATE$2 = 0.1;
function eventMethodCalled(method, payload) {
  return {
    event: EVENT_METHOD_CALLED,
    eventSamplingRate: EVENT_SAMPLING_RATE$2,
    payload: {
      method,
      ...payload
    }
  };
}

// node_modules/@clerk/shared/dist/runtime/organization-BqxdOtRG.mjs
function getCurrentOrganizationMembership(organizationMemberships, organizationId) {
  return organizationMemberships.find((organizationMembership) => organizationMembership.organization.id === organizationId);
}

// node_modules/@clerk/shared/dist/runtime/utils-BfsP_p13.mjs
var logErrorInDevMode = (message) => {
  if (isDevelopmentEnvironment()) console.error(`Clerk: ${message}`);
};

// node_modules/@clerk/shared/dist/runtime/browser-D5e8obql.mjs
function inBrowser() {
  return typeof window !== "undefined";
}
var botAgentRegex = new RegExp([
  "bot",
  "spider",
  "crawl",
  "APIs-Google",
  "AdsBot",
  "Googlebot",
  "mediapartners",
  "Google Favicon",
  "FeedFetcher",
  "Google-Read-Aloud",
  "DuplexWeb-Google",
  "googleweblight",
  "bing",
  "yandex",
  "baidu",
  "duckduck",
  "yahoo",
  "ecosia",
  "ia_archiver",
  "facebook",
  "instagram",
  "pinterest",
  "reddit",
  "slack",
  "twitter",
  "whatsapp",
  "youtube",
  "semrush"
].join("|"), "i");

// node_modules/@clerk/shared/dist/runtime/deriveState-ChDqlleE.mjs
var deriveState = (clerkOperational, state, initialState) => {
  if (!clerkOperational && initialState) return deriveFromSsrInitialState(initialState);
  return deriveFromClientSideState(state);
};
var deriveFromSsrInitialState = (initialState) => {
  const userId = initialState.userId;
  const user = initialState.user;
  const sessionId = initialState.sessionId;
  const sessionStatus = initialState.sessionStatus;
  const sessionClaims = initialState.sessionClaims;
  return {
    userId,
    user,
    sessionId,
    session: initialState.session,
    sessionStatus,
    sessionClaims,
    organization: initialState.organization,
    orgId: initialState.orgId,
    orgRole: initialState.orgRole,
    orgPermissions: initialState.orgPermissions,
    orgSlug: initialState.orgSlug,
    actor: initialState.actor,
    factorVerificationAge: initialState.factorVerificationAge
  };
};
var deriveFromClientSideState = (state) => {
  const userId = state.user ? state.user.id : state.user;
  const user = state.user;
  const sessionId = state.session ? state.session.id : state.session;
  const session = state.session;
  const sessionStatus = state.session?.status;
  const sessionClaims = state.session ? state.session.lastActiveToken?.jwt?.claims : null;
  const factorVerificationAge = state.session ? state.session.factorVerificationAge : null;
  const actor = session?.actor;
  const organization = state.organization;
  const orgId = state.organization ? state.organization.id : state.organization;
  const orgSlug = organization?.slug;
  const membership = organization ? user?.organizationMemberships?.find((om) => om.organization.id === orgId) : organization;
  const orgPermissions = membership ? membership.permissions : membership;
  return {
    userId,
    user,
    sessionId,
    session,
    sessionStatus,
    sessionClaims,
    organization,
    orgId,
    orgRole: membership ? membership.role : membership,
    orgSlug,
    orgPermissions,
    actor,
    factorVerificationAge
  };
};

// node_modules/@clerk/vue/dist/index.js
var useUser = () => {
  const { userCtx } = useClerkContext("useUser");
  const result = computed(() => {
    if (userCtx.value === void 0) {
      return { isLoaded: false, isSignedIn: void 0, user: void 0 };
    }
    if (userCtx.value === null) {
      return { isLoaded: true, isSignedIn: false, user: null };
    }
    return { isLoaded: true, isSignedIn: true, user: userCtx.value };
  });
  return toComputedRefs(result);
};
var useSession = () => {
  const { sessionCtx, clerk } = useClerkContext("useSession");
  const result = computed(() => {
    if (sessionCtx.value === void 0) {
      return { isLoaded: false, isSignedIn: void 0, session: void 0 };
    }
    const isSignedOut = sessionCtx.value === null;
    if (isSignedOut) {
      return { isLoaded: true, isSignedIn: false, session: null };
    }
    return { isLoaded: true, isSignedIn: !!clerk.value?.isSignedIn, session: sessionCtx.value };
  });
  return toComputedRefs(result);
};
var useSignIn = () => {
  const { clerk, clientCtx } = useClerkContext("useSignIn");
  watch(
    clerk,
    (value) => {
      if (value) {
        value.telemetry?.record(eventMethodCalled("useSignIn"));
      }
    },
    { once: true }
  );
  const result = computed(() => {
    if (!clerk.value || !clientCtx.value) {
      return { isLoaded: false, signIn: void 0, setActive: void 0 };
    }
    return {
      isLoaded: true,
      signIn: clientCtx.value.signIn,
      setActive: clerk.value.setActive
    };
  });
  return toComputedRefs(result);
};
var useSignUp = () => {
  const { clerk, clientCtx } = useClerkContext("useSignUp");
  watch(
    clerk,
    (value) => {
      if (value) {
        value.telemetry?.record(eventMethodCalled("useSignUp"));
      }
    },
    { once: true }
  );
  const result = computed(() => {
    if (!clerk.value || !clientCtx.value) {
      return { isLoaded: false, signUp: void 0, setActive: void 0 };
    }
    return {
      isLoaded: true,
      signUp: clientCtx.value.signUp,
      setActive: clerk.value.setActive
    };
  });
  return toComputedRefs(result);
};
var useSessionList = () => {
  const { clerk, clientCtx } = useClerkContext("useSessionList");
  const result = computed(() => {
    if (!clientCtx.value) {
      return { isLoaded: false, sessions: void 0, setActive: void 0 };
    }
    return {
      isLoaded: true,
      sessions: clientCtx.value.sessions,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setActive: clerk.value.setActive
    };
  });
  return toComputedRefs(result);
};
var useOrganization = () => {
  const { clerk, organizationCtx } = useClerkContext("useOrganization");
  const { session } = useSession();
  watch(
    clerk,
    (value) => {
      if (value) {
        value.__internal_attemptToEnableEnvironmentSetting?.({
          for: "organizations",
          caller: "useOrganization"
        });
      }
    },
    { once: true }
  );
  const result = computed(() => {
    if (organizationCtx.value === void 0) {
      return { isLoaded: false, organization: void 0, membership: void 0 };
    }
    if (organizationCtx.value === null) {
      return { isLoaded: true, organization: null, membership: null };
    }
    if (!clerk.value?.loaded) {
      return {
        isLoaded: true,
        organization: organizationCtx.value,
        membership: void 0
      };
    }
    return {
      isLoaded: clerk.value.loaded,
      organization: organizationCtx.value,
      membership: getCurrentOrganizationMembership(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        session.value.user.organizationMemberships,
        organizationCtx.value.id
      )
    };
  });
  return toComputedRefs(result);
};
var useClerkLoaded = (callback) => {
  const clerk = useClerk();
  let unwatch;
  unwatch = watch(
    clerk,
    (unwrappedClerk) => {
      if (!unwrappedClerk?.loaded) {
        return;
      }
      callback(unwrappedClerk);
      unwatch?.();
    },
    { immediate: true }
  );
};
function updateClerkOptions(options) {
  if (!window.Clerk) {
    throw new Error("Missing Clerk instance");
  }
  void window.Clerk.__unstable__updateProps({
    options: {
      localization: options.localization
    },
    appearance: options.appearance
  });
}
var SignedIn = defineComponent(({ treatPendingAsSignedOut }, { slots }) => {
  const { userId } = useAuth({ treatPendingAsSignedOut });
  return () => userId.value ? slots.default?.() : null;
});
Object.defineProperty(SignedIn, "props", {
  value: ["treatPendingAsSignedOut"]
});
var SignedOut = defineComponent(({ treatPendingAsSignedOut }, { slots }) => {
  const { userId } = useAuth({ treatPendingAsSignedOut });
  return () => userId.value === null ? slots.default?.() : null;
});
Object.defineProperty(SignedOut, "props", {
  value: ["treatPendingAsSignedOut"]
});
var ClerkLoaded = defineComponent((_, { slots }) => {
  const clerk = useClerk();
  return () => clerk.value?.loaded ? slots.default?.() : null;
});
var ClerkLoading = defineComponent((_, { slots }) => {
  const clerk = useClerk();
  return () => !clerk.value?.loaded ? slots.default?.() : null;
});
var RedirectToSignIn = defineComponent((props) => {
  const { sessionCtx, clientCtx } = useClerkContext("RedirectToSignIn");
  useClerkLoaded((clerk) => {
    const hasSignedInSessions = clientCtx.value?.signedInSessions && clientCtx.value.signedInSessions.length > 0;
    if (sessionCtx.value === null && hasSignedInSessions) {
      void clerk.redirectToAfterSignOut();
    } else {
      void clerk.redirectToSignIn(props);
    }
  });
  return () => null;
});
Object.defineProperty(RedirectToSignIn, "props", {
  value: ["signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl"]
});
var RedirectToSignUp = defineComponent((props) => {
  useClerkLoaded((clerk) => {
    void clerk.redirectToSignUp(props);
  });
  return () => null;
});
Object.defineProperty(RedirectToSignUp, "props", {
  value: ["signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl"]
});
var RedirectToTasks = defineComponent((props) => {
  useClerkLoaded((clerk) => {
    void clerk.redirectToTasks(props);
  });
  return () => null;
});
Object.defineProperty(RedirectToTasks, "props", {
  value: ["signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl"]
});
var RedirectToUserProfile = defineComponent(() => {
  useClerkLoaded((clerk) => {
    deprecated("RedirectToUserProfile", "Use the `redirectToUserProfile()` method instead.");
    void clerk.redirectToUserProfile();
  });
  return () => null;
});
var RedirectToOrganizationProfile = defineComponent(() => {
  useClerkLoaded((clerk) => {
    deprecated("RedirectToOrganizationProfile", "Use the `redirectToOrganizationProfile()` method instead.");
    void clerk.redirectToOrganizationProfile();
  });
  return () => null;
});
var RedirectToCreateOrganization = defineComponent(() => {
  useClerkLoaded((clerk) => {
    deprecated("RedirectToCreateOrganization", "Use the `redirectToCreateOrganization()` method instead.");
    void clerk.redirectToCreateOrganization();
  });
  return () => null;
});
var AuthenticateWithRedirectCallback = defineComponent((props) => {
  useClerkLoaded((clerk) => {
    void clerk.handleRedirectCallback(props);
  });
  return () => null;
});
Object.defineProperty(AuthenticateWithRedirectCallback, "props", {
  value: ["transferable", "signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl", "signInUrl", "signUpUrl", "firstFactorUrl", "secondFactorUrl", "resetPasswordUrl", "continueSignUpUrl", "verifyEmailAddressUrl", "verifyPhoneNumberUrl", "reloadResource", "unsafeMetadata"]
});
var Protect = defineComponent((props, { slots }) => {
  const { isLoaded, has, userId } = useAuth({ treatPendingAsSignedOut: props.treatPendingAsSignedOut });
  return () => {
    if (!isLoaded.value) {
      return null;
    }
    if (!userId.value) {
      return slots.fallback?.();
    }
    if (typeof props.condition === "function") {
      if (props.condition(has.value)) {
        return slots.default?.();
      }
      return slots.fallback?.();
    }
    if (props.role || props.permission || props.feature || props.plan) {
      if (has.value?.(props)) {
        return slots.default?.();
      }
      return slots.fallback?.();
    }
    return slots.default?.();
  };
});
Object.defineProperty(Protect, "props", {
  value: ["condition", "role", "permission", "feature", "plan", "treatPendingAsSignedOut"]
});
var CustomPortalsRenderer = defineComponent((props) => {
  return () => [...props?.customPagesPortals ?? [], ...props?.customMenuItemsPortals ?? []];
});
Object.defineProperty(CustomPortalsRenderer, "props", {
  value: ["customPagesPortals", "customMenuItemsPortals"]
});
var ClerkHostRenderer = defineComponent({
  props: {
    mount: {
      type: Function,
      required: false
    },
    unmount: {
      type: Function,
      required: false
    },
    open: {
      type: Function,
      required: false
    },
    close: {
      type: Function,
      required: false
    },
    updateProps: {
      type: Function,
      required: false
    },
    props: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  setup(props) {
    const portalRef = ref(null);
    let isPortalMounted = false;
    watchEffect(() => {
      if (!portalRef.value || isPortalMounted) {
        return;
      }
      if (props.mount) {
        props.mount(portalRef.value, props.props);
      }
      if (props.open) {
        props.open(props.props);
      }
      isPortalMounted = true;
    });
    watch(
      () => props.props,
      (newProps) => {
        if (isPortalMounted && props.updateProps && portalRef.value) {
          props.updateProps({ node: portalRef.value, props: newProps });
        }
      },
      { deep: true }
    );
    onUnmounted(() => {
      if (isPortalMounted && portalRef.value) {
        if (props.unmount) {
          props.unmount(portalRef.value);
        }
        if (props.close) {
          props.close();
        }
      }
    });
    return () => h(ClerkLoaded, () => h("div", { ref: portalRef }));
  }
});
var _sfc_main = defineComponent({
  __name: "SignIn",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    signInUrl: { type: String, required: false },
    signUpUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    initialValues: { type: Object, required: false },
    __experimental: { type: Object, required: false },
    waitlistUrl: { type: String, required: false },
    unsafeMetadata: { type: null, required: false },
    withSignUp: { type: Boolean, required: false, default: void 0 },
    oauthFlow: { type: String, required: false },
    oidcPrompt: { type: String, required: false },
    transferable: { type: Boolean, required: false, default: void 0 },
    signUpForceRedirectUrl: { type: [String, null], required: false },
    signUpFallbackRedirectUrl: { type: [String, null], required: false },
    afterSignInUrl: { type: [String, null], required: false },
    afterSignUpUrl: { type: [String, null], required: false },
    redirectUrl: { type: [String, null], required: false },
    afterSignOutUrl: { type: [String, null], required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountSignIn,
    unmount: $setup.clerk?.unmountSignIn,
    props: $setup.props,
    "update-props": $setup.clerk?.__unstable__updateProps
  }, null, 8, ["mount", "unmount", "update-props"]);
}
var SignIn_default = export_helper_default(_sfc_main, [["render", _sfc_render], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/SignIn.vue"]]);
var _sfc_main2 = defineComponent({
  __name: "SignUp",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    signInUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    unsafeMetadata: { type: null, required: false },
    initialValues: { type: Object, required: false },
    __experimental: { type: Object, required: false },
    waitlistUrl: { type: String, required: false },
    oauthFlow: { type: String, required: false },
    oidcPrompt: { type: String, required: false },
    signInFallbackRedirectUrl: { type: [String, null], required: false },
    signInForceRedirectUrl: { type: [String, null], required: false },
    afterSignInUrl: { type: [String, null], required: false },
    afterSignUpUrl: { type: [String, null], required: false },
    redirectUrl: { type: [String, null], required: false },
    afterSignOutUrl: { type: [String, null], required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountSignUp,
    unmount: $setup.clerk?.unmountSignUp,
    props: $setup.props,
    "update-props": $setup.clerk?.__unstable__updateProps
  }, null, 8, ["mount", "unmount", "props", "update-props"]);
}
var SignUp_default = export_helper_default(_sfc_main2, [["render", _sfc_render2], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/SignUp.vue"]]);
var _sfc_main3 = defineComponent({
  __name: "GoogleOneTap",
  props: {
    signInForceRedirectUrl: { type: [String, null], required: false },
    signUpForceRedirectUrl: { type: [String, null], required: false },
    cancelOnTapOutside: { type: Boolean, required: false, default: true },
    itpSupport: { type: Boolean, required: false, default: true },
    fedCmSupport: { type: Boolean, required: false, default: true },
    appearance: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    open: $setup.clerk?.openGoogleOneTap,
    close: $setup.clerk?.closeGoogleOneTap,
    props: $setup.props
  }, null, 8, ["open", "close"]);
}
var GoogleOneTap_default = export_helper_default(_sfc_main3, [["render", _sfc_render3], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/GoogleOneTap.vue"]]);
var _sfc_main4 = defineComponent({
  __name: "Waitlist",
  props: {
    afterJoinWaitlistUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    signInUrl: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountWaitlist,
    unmount: $setup.clerk?.unmountWaitlist,
    "update-props": $setup.clerk?.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var Waitlist_default = export_helper_default(_sfc_main4, [["render", _sfc_render4], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/Waitlist.vue"]]);
var _sfc_main5 = defineComponent({
  __name: "CreateOrganization",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    afterCreateOrganizationUrl: { type: [Function, Object], required: false, skipCheck: true },
    skipInvitationScreen: { type: Boolean, required: false },
    appearance: { type: Object, required: false },
    hideSlug: { type: Boolean, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountCreateOrganization,
    unmount: $setup.clerk?.unmountCreateOrganization,
    "update-props": $setup.clerk?.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var CreateOrganization_default = export_helper_default(_sfc_main5, [["render", _sfc_render5], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/CreateOrganization.vue"]]);
var _sfc_main6 = defineComponent({
  __name: "OrganizationList",
  props: {
    afterCreateOrganizationUrl: { type: [Function, Object], required: false, skipCheck: true },
    afterSelectOrganizationUrl: { type: [Function, Object], required: false, skipCheck: true },
    appearance: { type: Object, required: false },
    skipInvitationScreen: { type: Boolean, required: false },
    hidePersonal: { type: Boolean, required: false },
    afterSelectPersonalUrl: { type: [Function, Object], required: false, skipCheck: true },
    hideSlug: { type: Boolean, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountOrganizationList,
    unmount: $setup.clerk?.unmountOrganizationList,
    "update-props": $setup.clerk?.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var OrganizationList_default = export_helper_default(_sfc_main6, [["render", _sfc_render6], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/OrganizationList.vue"]]);
var _sfc_main7 = defineComponent({
  __name: "PricingTable",
  props: {
    for: { type: String, required: false },
    appearance: { type: Object, required: false },
    checkoutProps: { type: Object, required: false },
    ctaPosition: { type: String, required: false },
    collapseFeatures: { type: Boolean, required: false },
    newSubscriptionRedirectUrl: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountPricingTable,
    unmount: $setup.clerk?.unmountPricingTable,
    "update-props": $setup.clerk?.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var PricingTable_default = export_helper_default(_sfc_main7, [["render", _sfc_render7], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/PricingTable.vue"]]);
var _sfc_main8 = defineComponent({
  __name: "APIKeys",
  props: {
    perPage: { type: Number, required: false },
    appearance: { type: Object, required: false },
    showDescription: { type: Boolean, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountAPIKeys,
    unmount: $setup.clerk?.unmountAPIKeys,
    "update-props": $setup.clerk?.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var APIKeys_default = export_helper_default(_sfc_main8, [["render", _sfc_render8], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/APIKeys.vue"]]);
var _sfc_main9 = defineComponent({
  __name: "OrganizationProfile",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    afterLeaveOrganizationUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    __experimental_startPath: { type: String, required: false },
    apiKeysProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const { customPages, customPagesPortals, addCustomPage } = useOrganizationProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      customPages: customPages.value
    }));
    provide(OrganizationProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { props, clerk, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: $setup.clerk?.mountOrganizationProfile,
        unmount: $setup.clerk?.unmountOrganizationProfile,
        props: $setup.finalProps,
        "update-props": $setup.clerk?.__unstable__updateProps
      }, null, 8, ["mount", "unmount", "props", "update-props"]),
      createVNode($setup["CustomPortalsRenderer"], { "custom-pages-portals": $setup.customPagesPortals }, null, 8, ["custom-pages-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var OrganizationProfile_default = export_helper_default(_sfc_main9, [["render", _sfc_render9], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/OrganizationProfile/OrganizationProfile.vue"]]);
var OrganizationProfilePage = defineComponent(
  (props, { slots }) => {
    const ctx = inject(OrganizationProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(organizationProfilePageRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: OrganizationProfilePage
    });
    return () => null;
  },
  { name: "OrganizationProfilePage" }
);
Object.defineProperty(OrganizationProfilePage, "props", {
  value: ["label", "url"]
});
var OrganizationProfileLink = defineComponent(
  (props, { slots }) => {
    const ctx = inject(OrganizationProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(organizationProfileLinkRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: OrganizationProfileLink
    });
    return () => null;
  },
  { name: "OrganizationProfileLink" }
);
Object.defineProperty(OrganizationProfileLink, "props", {
  value: ["url", "label"]
});
var OrganizationProfile = Object.assign(OrganizationProfile_default, {
  Page: OrganizationProfilePage,
  Link: OrganizationProfileLink
});
var isThatComponent = (v, component) => {
  return !!v && isRenderFunction(v) && v.name === component.name;
};
var isRenderFunction = (v) => {
  return "name" in v && "setup" in v;
};
function generateElementIdentifier() {
  return Math.random().toString(36).substring(2, 7);
}
var useCustomElementPortal = () => {
  const rawPortals = ref([]);
  const portals = computed(() => {
    return rawPortals.value.map((item) => {
      return h(Teleport, { to: item.el }, item.slot());
    });
  });
  const mount = (el, slot) => {
    const id = generateElementIdentifier();
    el.setAttribute("data-clerk-mount-id", id);
    rawPortals.value.push({
      id,
      el,
      slot
    });
  };
  const unmount = (el) => {
    const id = el?.getAttribute("data-clerk-mount-id");
    if (id) {
      const index = rawPortals.value.findIndex((portal) => portal.id === id);
      if (index !== -1) {
        rawPortals.value.splice(index, 1);
      }
    }
  };
  return {
    portals,
    mount,
    unmount
  };
};
var useUserProfileCustomPages = () => {
  const { customPages, customPagesPortals, addCustomPage } = useCustomPages({
    reorderItemsLabels: ["account", "security", "billing", "apiKeys"],
    PageComponent: UserProfilePage,
    LinkComponent: UserProfileLink,
    componentName: "UserProfile"
  });
  const addUserProfileCustomPage = (params) => {
    return addCustomPage(params);
  };
  return {
    customPages,
    customPagesPortals,
    addCustomPage: addUserProfileCustomPage
  };
};
var useOrganizationProfileCustomPages = () => {
  const { customPages, customPagesPortals, addCustomPage } = useCustomPages({
    reorderItemsLabels: ["general", "members", "billing", "apiKeys"],
    PageComponent: OrganizationProfilePage,
    LinkComponent: OrganizationProfileLink,
    componentName: "OrganizationProfile"
  });
  const addOrganizationProfileCustomPage = (params) => {
    return addCustomPage(params);
  };
  return {
    customPages,
    customPagesPortals,
    addCustomPage: addOrganizationProfileCustomPage
  };
};
var useCustomPages = (customPagesParams) => {
  const customPages = ref([]);
  const { portals: customPagesPortals, mount, unmount } = useCustomElementPortal();
  const { PageComponent, LinkComponent, reorderItemsLabels, componentName } = customPagesParams;
  const addCustomPage = (params) => {
    const { props, slots, component } = params;
    const { label, url } = props;
    if (isThatComponent(component, PageComponent)) {
      if (isReorderItem(props, slots, reorderItemsLabels)) {
        customPages.value.push({ label });
      } else if (isCustomPage(props, slots)) {
        customPages.value.push({
          label,
          url,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount,
          mount(el) {
            mount(el, slots.default);
          },
          unmount
        });
      } else {
        logErrorInDevMode(customPageWrongProps(componentName));
        return;
      }
    }
    if (isThatComponent(component, LinkComponent)) {
      if (isExternalLink(props, slots)) {
        customPages.value.push({
          label,
          url,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount
        });
      } else {
        logErrorInDevMode(customLinkWrongProps(componentName));
        return;
      }
    }
  };
  return {
    customPages,
    customPagesPortals,
    addCustomPage
  };
};
var isReorderItem = (props, slots, validItems) => {
  const { label, url } = props;
  const { default: defaultSlot, labelIcon } = slots;
  return !defaultSlot && !url && !labelIcon && validItems.some((v) => v === label);
};
var isCustomPage = (props, slots) => {
  const { label, url } = props;
  const { default: defaultSlot, labelIcon } = slots;
  return !!defaultSlot && !!url && !!labelIcon && !!label;
};
var isExternalLink = (props, slots) => {
  const { label, url } = props;
  const { default: defaultSlot, labelIcon } = slots;
  return !defaultSlot && !!url && !!labelIcon && !!label;
};
var _sfc_main10 = defineComponent({
  __name: "UserProfile",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    appearance: { type: Object, required: false },
    additionalOAuthScopes: { type: Object, required: false },
    __experimental_startPath: { type: String, required: false },
    apiKeysProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const { customPages, customPagesPortals, addCustomPage } = useUserProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      customPages: customPages.value
    }));
    provide(UserProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { props, clerk, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: $setup.clerk?.mountUserProfile,
        unmount: $setup.clerk?.unmountUserProfile,
        props: $setup.finalProps,
        "update-props": $setup.clerk?.__unstable__updateProps
      }, null, 8, ["mount", "unmount", "props", "update-props"]),
      createVNode($setup["CustomPortalsRenderer"], { "custom-pages-portals": $setup.customPagesPortals }, null, 8, ["custom-pages-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var UserProfile_default = export_helper_default(_sfc_main10, [["render", _sfc_render10], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/UserProfile/UserProfile.vue"]]);
var UserProfilePage = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userProfilePageRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: UserProfilePage
    });
    return () => null;
  },
  { name: "UserProfilePage" }
);
Object.defineProperty(UserProfilePage, "props", {
  value: ["label", "url"]
});
var UserProfileLink = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userProfileLinkRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: UserProfileLink
    });
    return () => null;
  },
  { name: "UserProfileLink" }
);
Object.defineProperty(UserProfileLink, "props", {
  value: ["url", "label"]
});
var UserProfile = Object.assign(UserProfile_default, {
  Page: UserProfilePage,
  Link: UserProfileLink
});
var _sfc_main11 = defineComponent({
  __name: "OrganizationSwitcher",
  props: {
    createOrganizationUrl: { type: null, required: false },
    createOrganizationMode: { type: String, required: false },
    organizationProfileUrl: { type: null, required: false },
    organizationProfileMode: { type: String, required: false },
    defaultOpen: { type: Boolean, required: false },
    hidePersonal: { type: Boolean, required: false },
    afterSwitchOrganizationUrl: { type: String, required: false },
    afterCreateOrganizationUrl: { type: [Function, Object], required: false, skipCheck: true },
    afterSelectOrganizationUrl: { type: [Function, Object], required: false, skipCheck: true },
    afterSelectPersonalUrl: { type: [Function, Object], required: false, skipCheck: true },
    afterLeaveOrganizationUrl: { type: String, required: false },
    skipInvitationScreen: { type: Boolean, required: false },
    hideSlug: { type: Boolean, required: false },
    appearance: { type: Object, required: false },
    organizationProfileProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const { customPages, customPagesPortals, addCustomPage } = useOrganizationProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      organizationProfileProps: {
        ...props.organizationProfileProps || {},
        customPages: customPages.value
      }
    }));
    provide(OrganizationProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { clerk, props, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: $setup.clerk?.mountOrganizationSwitcher,
        unmount: $setup.clerk?.unmountOrganizationSwitcher,
        "update-props": $setup.clerk?.__unstable__updateProps,
        props: $setup.finalProps
      }, null, 8, ["mount", "unmount", "update-props", "props"]),
      createVNode($setup["CustomPortalsRenderer"], { "custom-pages-portals": $setup.customPagesPortals }, null, 8, ["custom-pages-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var OrganizationSwitcher_default = export_helper_default(_sfc_main11, [["render", _sfc_render11], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/OrganizationSwitcher/OrganizationSwitcher.vue"]]);
var OrganizationSwitcher = Object.assign(OrganizationSwitcher_default, {
  OrganizationProfilePage,
  OrganizationProfileLink
});
var _sfc_main12 = defineComponent({
  __name: "UserAvatar",
  props: {
    appearance: { type: Object, required: false },
    rounded: { type: Boolean, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: $setup.clerk?.mountUserAvatar,
    unmount: $setup.clerk?.unmountUserAvatar,
    "update-props": $setup.clerk?.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var UserAvatar_default = export_helper_default(_sfc_main12, [["render", _sfc_render12], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/UserAvatar.vue"]]);
var useUserButtonCustomMenuItems = () => {
  const customMenuItems = ref([]);
  const { portals: customMenuItemsPortals, mount, unmount } = useCustomElementPortal();
  const reorderItemsLabels = ["manageAccount", "signOut"];
  function addCustomMenuItem(params) {
    const { props, component, slots } = params;
    const { label, onClick, open, href } = props;
    if (isThatComponent(component, MenuAction)) {
      if (isReorderItem2(props, slots, reorderItemsLabels)) {
        customMenuItems.value.push({ label });
      } else if (isCustomMenuItem(props, slots)) {
        const baseItem = {
          label,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount
        };
        if (onClick !== void 0) {
          customMenuItems.value.push({
            ...baseItem,
            onClick,
            open
          });
        } else if (open !== void 0) {
          customMenuItems.value.push({
            ...baseItem,
            open: open.startsWith("/") ? open : `/${open}`
          });
        } else {
          logErrorInDevMode("Custom menu item must have either onClick or open property");
          return;
        }
      } else {
        logErrorInDevMode(userButtonMenuItemActionWrongProps);
        return;
      }
    }
    if (isThatComponent(component, MenuLink)) {
      if (isExternalLink2(props, slots)) {
        customMenuItems.value.push({
          label,
          href,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount
        });
      } else {
        logErrorInDevMode(userButtonMenuItemLinkWrongProps);
        return;
      }
    }
  }
  return {
    customMenuItems,
    customMenuItemsPortals,
    addCustomMenuItem
  };
};
var isReorderItem2 = (props, slots, validItems) => {
  const { label, onClick } = props;
  const { labelIcon } = slots;
  return !onClick && !labelIcon && validItems.some((v) => v === label);
};
var isCustomMenuItem = (props, slots) => {
  const { label, onClick, open } = props;
  const { labelIcon } = slots;
  return !!labelIcon && !!label && (typeof onClick === "function" || typeof open === "string");
};
var isExternalLink2 = (props, slots) => {
  const { label, href } = props;
  const { labelIcon } = slots;
  return !!href && !!labelIcon && !!label;
};
var _sfc_main13 = defineComponent({
  __name: "UserButton",
  props: {
    userProfileUrl: { type: null, required: false },
    userProfileMode: { type: String, required: false },
    showName: { type: Boolean, required: false },
    defaultOpen: { type: Boolean, required: false },
    __experimental_asStandalone: { type: [Boolean, Function], required: false },
    afterSignOutUrl: { type: String, required: false },
    afterMultiSessionSingleSignOutUrl: { type: String, required: false },
    signInUrl: { type: String, required: false },
    afterSwitchSessionUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    userProfileProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const { customMenuItems, customMenuItemsPortals, addCustomMenuItem } = useUserButtonCustomMenuItems();
    const { customPages, customPagesPortals, addCustomPage } = useUserProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      userProfileProps: {
        ...props.userProfileProps || {},
        customPages: customPages.value
      },
      customMenuItems: customMenuItems.value
    }));
    provide(UserButtonInjectionKey, {
      addCustomMenuItem
    });
    provide(UserProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { props, clerk, customMenuItems, customMenuItemsPortals, addCustomMenuItem, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: $setup.clerk?.mountUserButton,
        unmount: $setup.clerk?.unmountUserButton,
        props: $setup.finalProps,
        "update-props": $setup.clerk?.__unstable__updateProps
      }, null, 8, ["mount", "unmount", "props", "update-props"]),
      createVNode($setup["CustomPortalsRenderer"], {
        "custom-pages-portals": $setup.customPagesPortals,
        "custom-menu-items-portals": $setup.customMenuItemsPortals
      }, null, 8, ["custom-pages-portals", "custom-menu-items-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var UserButton_default = export_helper_default(_sfc_main13, [["render", _sfc_render13], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/UserButton/UserButton.vue"]]);
var MenuItems = defineComponent((_, { slots }) => {
  const ctx = inject(UserButtonInjectionKey);
  if (!ctx) {
    return errorThrower.throw(userButtonMenuItemsRenderedError);
  }
  provide(UserButtonMenuItemsInjectionKey, ctx);
  return () => slots.default?.();
});
var MenuAction = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserButtonMenuItemsInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userButtonMenuActionRenderedError);
    }
    ctx.addCustomMenuItem({
      props,
      slots,
      component: MenuAction
    });
    return () => null;
  },
  { name: "MenuAction" }
);
Object.defineProperty(MenuAction, "props", {
  value: ["label", "onClick", "open"]
});
var MenuLink = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserButtonMenuItemsInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userButtonMenuLinkRenderedError);
    }
    ctx.addCustomMenuItem({
      props,
      slots,
      component: MenuLink
    });
    return () => null;
  },
  { name: "MenuLink" }
);
Object.defineProperty(MenuLink, "props", {
  value: ["href", "label"]
});
var UserButton = Object.assign(UserButton_default, {
  MenuItems,
  Action: MenuAction,
  Link: MenuLink,
  UserProfilePage,
  UserProfileLink
});
var _sfc_main14 = defineComponent({
  __name: "SignInButton",
  props: {
    mode: { type: String, required: false },
    appearance: { type: Object, required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    signUpForceRedirectUrl: { type: [String, null], required: false },
    signUpFallbackRedirectUrl: { type: [String, null], required: false },
    initialValues: { type: Object, required: false },
    withSignUp: { type: Boolean, required: false },
    oauthFlow: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      const children = normalizeWithDefaultValue(slots.default?.({}), "Sign in");
      return assertSingleChild(children, "SignInButton");
    }
    function clickHandler() {
      const { mode, ...opts } = props;
      if (mode === "modal") {
        return clerk.value?.openSignIn({ ...opts, appearance: props.appearance });
      }
      const { withSignUp, ...redirectOpts } = opts;
      void clerk.value?.redirectToSignIn({
        ...redirectOpts,
        signInFallbackRedirectUrl: props.fallbackRedirectUrl,
        signInForceRedirectUrl: props.forceRedirectUrl
      });
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignInButton_default = export_helper_default(_sfc_main14, [["render", _sfc_render14], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignInButton.vue"]]);
var _sfc_main15 = defineComponent({
  __name: "SignUpButton",
  props: {
    mode: { type: String, required: false },
    appearance: { type: Object, required: false },
    unsafeMetadata: { type: null, required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    signInForceRedirectUrl: { type: [String, null], required: false },
    signInFallbackRedirectUrl: { type: [String, null], required: false },
    initialValues: { type: Object, required: false },
    oauthFlow: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      const children = normalizeWithDefaultValue(slots.default?.({}), "Sign up");
      return assertSingleChild(children, "SignUpButton");
    }
    function clickHandler() {
      const { mode, ...opts } = props;
      if (mode === "modal") {
        return clerk.value?.openSignUp({ ...opts, appearance: props.appearance });
      }
      void clerk.value?.redirectToSignUp({
        ...opts,
        signUpFallbackRedirectUrl: props.fallbackRedirectUrl,
        signUpForceRedirectUrl: props.forceRedirectUrl
      });
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignUpButton_default = export_helper_default(_sfc_main15, [["render", _sfc_render15], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignUpButton.vue"]]);
var _sfc_main16 = defineComponent({
  __name: "SignOutButton",
  props: {
    signOutOptions: { type: Object, required: false },
    sessionId: { type: String, required: false },
    redirectUrl: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      const children = normalizeWithDefaultValue(slots.default?.({}), "Sign out");
      return assertSingleChild(children, "SignOutButton");
    }
    function clickHandler() {
      const signOutOptions = {
        redirectUrl: props.signOutOptions?.redirectUrl ?? props.redirectUrl,
        sessionId: props.signOutOptions?.sessionId ?? props.sessionId
      };
      void clerk.value?.signOut(signOutOptions);
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignOutButton_default = export_helper_default(_sfc_main16, [["render", _sfc_render16], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignOutButton.vue"]]);
var _sfc_main17 = defineComponent({
  __name: "SignInWithMetamaskButton",
  props: {
    redirectUrl: { type: [String, null], required: false },
    mode: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      const children = normalizeWithDefaultValue(slots.default?.({}), "Sign in with Metamask");
      return assertSingleChild(children, "SignInWithMetamaskButton");
    }
    function clickHandler() {
      void clerk.value?.authenticateWithMetamask({ redirectUrl: props.redirectUrl || void 0 });
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignInWithMetamaskButton_default = export_helper_default(_sfc_main17, [["render", _sfc_render17], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignInWithMetamaskButton.vue"]]);
var SDK_METADATA = {
  name: "@clerk/vue",
  version: "1.17.12",
  environment: "development"
};
var clerkPlugin = {
  install(app, pluginOptions) {
    const { initialState } = pluginOptions || {};
    const loaded = shallowRef(false);
    const clerk = shallowRef(null);
    const resources = ref({
      client: void 0,
      session: void 0,
      user: void 0,
      organization: void 0
    });
    const options = {
      ...pluginOptions,
      sdkMetadata: pluginOptions.sdkMetadata || SDK_METADATA
    };
    if (inBrowser()) {
      void loadClerkJsScript(options).then(async () => {
        if (!window.Clerk) {
          throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
        }
        clerk.value = window.Clerk;
        await window.Clerk.load(options);
        loaded.value = true;
        clerk.value.addListener((payload) => {
          resources.value = payload;
        });
        triggerRef(clerk);
      });
    }
    const derivedState = computed(() => deriveState(loaded.value, resources.value, initialState));
    const authCtx = computed(() => {
      const {
        sessionId,
        userId,
        orgId,
        actor,
        orgRole,
        orgSlug,
        orgPermissions,
        sessionStatus,
        sessionClaims,
        factorVerificationAge
      } = derivedState.value;
      return {
        sessionId,
        userId,
        actor,
        orgId,
        orgRole,
        orgSlug,
        orgPermissions,
        sessionStatus,
        sessionClaims,
        factorVerificationAge
      };
    });
    const clientCtx = computed(() => resources.value.client);
    const userCtx = computed(() => derivedState.value.user);
    const sessionCtx = computed(() => derivedState.value.session);
    const organizationCtx = computed(() => derivedState.value.organization);
    app.provide(ClerkInjectionKey, {
      clerk,
      authCtx,
      clientCtx,
      sessionCtx,
      userCtx,
      organizationCtx
    });
  }
};
setErrorThrowerOptions({ packageName: "@clerk/vue" });
setClerkJsLoadingErrorPackageName("@clerk/vue");
export {
  APIKeys_default as APIKeys,
  AuthenticateWithRedirectCallback,
  ClerkLoaded,
  ClerkLoading,
  CreateOrganization_default as CreateOrganization,
  GoogleOneTap_default as GoogleOneTap,
  OrganizationList_default as OrganizationList,
  OrganizationProfile,
  OrganizationSwitcher,
  PricingTable_default as PricingTable,
  Protect,
  RedirectToCreateOrganization,
  RedirectToOrganizationProfile,
  RedirectToSignIn,
  RedirectToSignUp,
  RedirectToTasks,
  RedirectToUserProfile,
  SignIn_default as SignIn,
  SignInButton_default as SignInButton,
  SignInWithMetamaskButton_default as SignInWithMetamaskButton,
  SignOutButton_default as SignOutButton,
  SignUp_default as SignUp,
  SignUpButton_default as SignUpButton,
  SignedIn,
  SignedOut,
  UserAvatar_default as UserAvatar,
  UserButton,
  UserProfile,
  Waitlist_default as Waitlist,
  clerkPlugin,
  updateClerkOptions,
  useAuth,
  useClerk,
  useOrganization,
  useSession,
  useSessionList,
  useSignIn,
  useSignUp,
  useUser
};
//# sourceMappingURL=@clerk_vue.js.map
